// Partially generated by Doubao (28/07/2025)

#ifndef SUFFIXTREE
#define SUFFIXTREE
#include "headers.h"

// Forward declaration
class Node;

class Edge {
public:
    int start;          // Start index of substring in original string
    int end;            // End index of substring in original string
    Node* child;        // Child node this edge points to

    Edge(int s, int e, Node* c) : start(s), end(e), child(c) {}
};

class Node {
public:
    // Map from first character to edge
    std::map<char, Edge*> edges;

    Node() {}
    ~Node() {
        // Clean up edges
        for (auto& pair : edges) {
            delete pair.second->child;
            delete pair.second;
        }
    }
};

class SuffixTree {
private:
    std::string s;      // Original string with terminator
    Node* root;         // Root node of the tree

    // Helper function to get match length between edge and suffix
    int getMatchLength(Edge* edge, int current_pos) {
        int match_len = 0;
        int max_possible = std::min(
            edge->end - edge->start + 1,
            (int)s.length() - current_pos
        );

        while (match_len < max_possible && 
               s[edge->start + match_len] == s[current_pos + match_len]) {
            match_len++;
        }
        return match_len;
    }

    // Helper function to split an edge
    void splitEdge(Node* parent, Edge* edge, int current_pos, int match_len) {
        // Create new internal node
        Node* internal_node = new Node();
        int original_start = edge->start;
        int original_end = edge->end;
        Node* original_child = edge->child;

        // Update parent's edge to point to internal node (first part of split)
        char split_char = s[original_start];
        parent->edges[split_char] = new Edge(
            original_start, 
            original_start + match_len - 1, 
            internal_node
        );

        // Remove old edge from parent
        delete edge;

        // Add edge from internal node to original child (second part of split)
        internal_node->edges[s[original_start + match_len]] = new Edge(
            original_start + match_len,
            original_end,
            original_child
        );

        // Add new edge for remaining part of the suffix
        int remaining_start = current_pos + match_len;
        internal_node->edges[s[remaining_start]] = new Edge(
            remaining_start,
            (int)s.length() - 1,
            new Node()
        );
    }

    // Helper function to add a suffix
    void addSuffix(int suffix_start) {
        Node* current = root;
        int current_pos = suffix_start;
        int n = s.length();

        while (current_pos < n) {
            char current_char = s[current_pos];

            // Check if current node has an edge starting with current_char
            if (current->edges.find(current_char) == current->edges.end()) {
                // No edge exists - create new edge to leaf node
                current->edges[current_char] = new Edge(
                    current_pos, 
                    n - 1, 
                    new Node()
                );
                break;
            } else {
                // Edge exists - check for matches
                Edge* edge = current->edges[current_char];
                int match_len = getMatchLength(edge, current_pos);
                int edge_length = edge->end - edge->start + 1;

                if (match_len == edge_length) {
                    // Entire edge matches - move to child node
                    current = edge->child;
                    current_pos += match_len;
                } else {
                    // Partial match - split the edge
                    splitEdge(current, edge, current_pos, match_len);
                    break;
                }
            }
        }
    }

    // Helper function for printing the tree
    void printHelper(Node* node, const std::string& prefix) {
        for (const auto& pair : node->edges) {
            char c = pair.first;
            Edge* edge = pair.second;
            std::string substr = s.substr(edge->start, edge->end - edge->start + 1);
            std::cout << prefix << "├─ '" << substr << "' (start=" << edge->start 
                      << ", end=" << edge->end << ")\n";
            printHelper(edge->child, prefix + "│  ");
        }
    }

public:
    // Constructor - takes input string and builds the tree
    SuffixTree(const std::string& input) {
        s = input + "$";  // Add unique terminator
        root = new Node();
        build();
    }

    // Destructor - clean up memory
    ~SuffixTree() {
        delete root;
    }

    // Build the suffix tree by adding all suffixes
    void build() {
        for (int i = 0; i < (int)s.length(); i++) {
            addSuffix(i);
        }
    }

    // Print the tree structure
    void print() {
        std::cout << "Suffix Tree Structure:\n";
        printHelper(root, "");
    }

    Node* get_root() {
        return root;
    }
};

#endif