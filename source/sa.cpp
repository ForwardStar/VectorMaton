// Partially generated by ChatGPT (11/08/2025)

#include "sa.h"

GeneralizedSuffixAutomaton::GeneralizedSuffixAutomaton() {
    st.clear();
    st.emplace_back(); // state 0 = initial
    st[0].link = -1;
    last = 0;
}

int GeneralizedSuffixAutomaton::size() {
    return st.size();
}

void GeneralizedSuffixAutomaton::clear() {
    st.clear();
    st.emplace_back();
    st[0].link = -1;
    last = 0;
}

void GeneralizedSuffixAutomaton::sa_extend(char c, int id) {
    if (st[last].next.count(c)) {
        int x = st[last].next[c];
        if (st[x].len == st[last].len + 1) {
            last = x;
        }
        else {
            // Clone st[last].next[c]
            int cur = (int)st.size();
            st.emplace_back();
            st[cur].len = st[last].len + 1;
            st[cur].next = st[x].next; // copy map
            st[cur].link = st[x].link;
            affected_states.emplace_back(cur);
            for (auto old_id : st[x].ids) { // copy ids
                st[cur].ids.emplace_back(old_id);
            }
            int p = last;
            while (p != -1 && st[p].next[c] == x) {
                st[p].next[c] = cur;
                p = st[p].link;
            }
            st[x].link = cur;
            last = cur;
        }

        // Propagate IDs
        int p = last;
        while (p != -1) {
            if (st[p].ids.empty() || st[p].ids.back() != id) affected_states.emplace_back(p), st[p].ids.emplace_back(id); else break;
            p = st[p].link;
        }
        return;
    }
    int cur = (int)st.size();
    st.emplace_back();
    st[cur].len = st[last].len + 1;

    int p = last;
    while (p != -1 && !st[p].next.count(c)) {
        st[p].next[c] = cur;
        p = st[p].link;
    }
    if (p == -1) {
        st[cur].link = 0;
    } else {
        int q = st[p].next[c];
        if (st[p].len + 1 == st[q].len) {
            st[cur].link = q;
        } else {
            // clone q
            int clone = (int)st.size();
            st.emplace_back();
            st[clone].len = st[p].len + 1;
            st[clone].next = st[q].next; // copy map
            st[clone].link = st[q].link;
            affected_states.emplace_back(clone);
            for (auto old_id : st[q].ids) { // copy ids
                st[clone].ids.emplace_back(old_id);
            }

            while (p != -1 && st[p].next[c] == q) {
                st[p].next[c] = clone;
                p = st[p].link;
            }
            st[q].link = st[cur].link = clone;
        }
    }

    last = cur;
    p = last;
    while (p != -1) {
        if (st[p].ids.empty() || st[p].ids.back() != id) affected_states.emplace_back(p), st[p].ids.emplace_back(id); else break;
        p = st[p].link;
    }
}

void GeneralizedSuffixAutomaton::add_string(int id, const std::string &s) {
    // We'll add characters of s by extending the automaton while resetting 'last' at the start
    // so the string is added as a separate sequence (avoiding cross-string suffixes).
    affected_states.clear();
    affected_states.emplace_back(0);
    last = 0;
    st[0].ids.emplace_back(id);
    for (char c : s) {
        sa_extend(c, id);
    }
}

int GeneralizedSuffixAutomaton::query(const std::string &p) const {
    int v = 0;
    for (char c : p) {
        auto it = st[v].next.find(c);
        if (it == st[v].next.end()) return -1;
        v = it->second;
    }
    // v is the state representing all end positions of strings that contain p
    // return its stored IDs
    return v;
}

int GeneralizedSuffixAutomaton::size_tot() {
    int tot_size = 0;
    for (size_t i = 0; i < st.size(); ++i) {
        tot_size += st[i].ids.size();
    }
    return tot_size;
}

void GeneralizedSuffixAutomaton::print() const {
    std::cout << "GeneralizedSuffixAutomaton with " << st.size() << " states\n";
    for (size_t i = 0; i < st.size(); ++i) {
        const auto &state = st[i];
        std::cout << "State " << i << ": len=" << state.len << ", link=" << state.link << "\n";
        std::cout << "  transitions: ";
        for (const auto &t : state.next) {
            std::cout << "'" << t.first << "'->" << t.second << "  ";
        }
        std::cout << "\n";
        std::cout << "  ids: {";
        for (size_t j = 0; j < state.ids.size(); ++j) {
            std::cout << state.ids[j];
            if (j + 1 < state.ids.size()) std::cout << ", ";
        }
        std::cout << "}\n";
    }
}