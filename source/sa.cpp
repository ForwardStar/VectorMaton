// Partially generated by ChatGPT (11/08/2025)

#include "sa.h"

GeneralizedSuffixAutomaton::GeneralizedSuffixAutomaton() {
    st.clear();
    st.emplace_back(); // state 0 = initial
    st[0].link = -1;
    last = 0;
}

GeneralizedSuffixAutomaton::GeneralizedSuffixAutomaton(char* input_file) {
    std::ifstream f(input_file);
    int n;
    f >> n;
    st.resize(n);
    for (int i = 0; i < n; i++) {
        int m, k;
        f >> st[i].len >> st[i].link >> m >> k;
        for (int j = 0; j < m; j++) {
            int x, y;
            f >> x >> y;
            st[i].next[char(x)] = y;
        }
        st[i].ids.resize(k);
        for (int j = 0; j < k; j++) {
            f >> st[i].ids[j];
        }
    }
    f.close();
}

int GeneralizedSuffixAutomaton::size() {
    return st.size();
}

void GeneralizedSuffixAutomaton::clear() {
    st.clear();
    st.emplace_back();
    st[0].link = -1;
    last = 0;
}

void GeneralizedSuffixAutomaton::sa_extend(char c, uint32_t id) {
    if (st[last].next.count(c)) {
        int x = st[last].next[c];
        if (st[x].len == st[last].len + 1) {
            last = x;
        }
        else {
            // Clone st[last].next[c]
            int cur = (int)st.size();
            st.emplace_back();
            st[cur].len = st[last].len + 1;
            for (auto e : st[x].next) {
                st[cur].next[e.first] = e.second; // copy map
            }
            st[cur].link = st[x].link;
            affected_states.emplace_back(cur);
            for (auto old_id : st[x].ids) { // copy ids
                st[cur].ids.emplace_back(old_id);
            }
            int p = last;
            while (p != -1 && st[p].next[c] == x) {
                st[p].next[c] = cur;
                p = st[p].link;
            }
            st[x].link = cur;
            last = cur;
        }

        // Propagate IDs
        int p = last;
        while (p != -1) {
            if (st[p].ids.empty() || st[p].ids.back() != id) affected_states.emplace_back(p), st[p].ids.emplace_back(id); else break;
            p = st[p].link;
        }
        return;
    }
    int cur = (int)st.size();
    st.emplace_back();
    st[cur].len = st[last].len + 1;

    int p = last;
    while (p != -1 && !st[p].next.count(c)) {
        st[p].next[c] = cur;
        p = st[p].link;
    }
    if (p == -1) {
        st[cur].link = 0;
    } else {
        int q = st[p].next[c];
        if (st[p].len + 1 == st[q].len) {
            st[cur].link = q;
        } else {
            // clone q
            int clone = (int)st.size();
            st.emplace_back();
            st[clone].len = st[p].len + 1;
            for (auto e : st[q].next) {
                st[clone].next[e.first] = e.second; // copy map
            }
            st[clone].link = st[q].link;
            affected_states.emplace_back(clone);
            for (auto old_id : st[q].ids) { // copy ids
                st[clone].ids.emplace_back(old_id);
            }

            while (p != -1 && st[p].next[c] == q) {
                st[p].next[c] = clone;
                p = st[p].link;
            }
            st[q].link = st[cur].link = clone;
        }
    }

    last = cur;
    p = last;
    while (p != -1) {
        if (st[p].ids.empty() || st[p].ids.back() != id) affected_states.emplace_back(p), st[p].ids.emplace_back(id); else break;
        p = st[p].link;
    }
}

void GeneralizedSuffixAutomaton::add_string(uint32_t id, const std::string &s) {
    // We'll add characters of s by extending the automaton while resetting 'last' at the start
    // so the string is added as a separate sequence (avoiding cross-string suffixes).
    affected_states.clear();
    affected_states.emplace_back(0);
    last = 0;
    st[0].ids.emplace_back(id);
    for (char c : s) {
        if (c >= 'a' && c <= 'z') {
            sa_extend(c, id);
        }
        else {
            LOG_WARN("Non-alphabetic character '", c, "' in the ", id, "-th string: did you pre-process data correctly?");
        }
    }
}

int GeneralizedSuffixAutomaton::query(const std::string &p) const {
    int v = 0;
    for (char c : p) {
        auto it = st[v].next.find(c);
        if (it == st[v].next.end()) return -1;
        v = it->second;
    }
    // v is the state representing all end positions of strings that contain p
    // return its stored IDs
    return v;
}

int GeneralizedSuffixAutomaton::size_tot() {
    int tot_size = 0;
    for (size_t i = 0; i < st.size(); ++i) {
        tot_size += st[i].ids.size();
    }
    return tot_size;
}

void GeneralizedSuffixAutomaton::print() const {
    std::cout << "GeneralizedSuffixAutomaton with " << st.size() << " states\n";
    for (size_t i = 0; i < st.size(); ++i) {
        const auto &state = st[i];
        std::cout << "State " << i << ": len=" << state.len << ", link=" << state.link << "\n";
        std::cout << "  transitions: ";
        for (const auto &t : state.next) {
            std::cout << "'" << t.first << "'->" << t.second << "  ";
        }
        std::cout << "\n";
        std::cout << "  ids: {";
        for (size_t j = 0; j < state.ids.size(); ++j) {
            std::cout << state.ids[j];
            if (j + 1 < state.ids.size()) std::cout << ", ";
        }
        std::cout << "}\n";
    }
}

std::vector<GeneralizedSuffixAutomaton::Statistics> GeneralizedSuffixAutomaton::get_statistics() const {
    std::vector<Statistics> stats;
    std::queue<std::pair<int, int>> q;
    q.emplace(0, 0); // state id, depth
    while (!q.empty()) {
        auto [state_id, depth] = q.front();
        q.pop();
        if (stats.size() <= static_cast<size_t>(depth)) {
            stats.emplace_back();
        }
        stats[depth].sizes.push_back(static_cast<int>(st[state_id].ids.size()));
        for (const auto &t : st[state_id].next) {
            q.emplace(t.second, depth + 1);
        }
    }
    for (auto &stat : stats) {
        std::sort(stat.sizes.begin(), stat.sizes.end());
        int n = static_cast<int>(stat.sizes.size());
        if (n % 2 == 1) {
            stat.mid = stat.sizes[n / 2];
        } else {
            stat.mid = (stat.sizes[n / 2 - 1] + stat.sizes[n / 2]) / 2.0;
        }
        double sum = 0.0;
        for (int size : stat.sizes) {
            sum += size;
        }
        stat.avg = sum / n;
    }
    return stats;
}

std::vector<int> GeneralizedSuffixAutomaton::topo_sort() const {
    int n = static_cast<int>(st.size());
    int* in_degree = new int[n];
    for (int i = 0; i < n; ++i) {
        in_degree[i] = 0;
    }
    for (int i = 0; i < n; ++i) {
        for (const auto &t : st[i].next) {
            in_degree[t.second]++;
        }
    }
    std::queue<int> q;
    for (int i = 0; i < n; ++i) {
        if (in_degree[i] == 0) {
            q.push(i);
        }
    }
    std::vector<int> order;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        order.push_back(u);
        for (const auto &t : st[u].next) {
            int v = t.second;
            in_degree[v]--;
            if (in_degree[v] == 0) {
                q.push(v);
            }
        }
    }
    // Bug check
    for (int i = 0; i < n; i++) {
        if (in_degree[i] != 0) {
            LOG_ERROR("Cycle detected in GSA states!");
        }
    }
    delete [] in_degree;
    return order;
}

void GeneralizedSuffixAutomaton::dump(char* output_file) {
    std::ofstream f(output_file);
    f << st.size() << "\n";
    for (int i = 0; i < st.size(); i++) {
        f << st[i].len << " " << st[i].link << " " << st[i].next.size() << " " << st[i].ids.size() << "\n";
        for (auto e : st[i].next) {
            f << int(e.first) << " " << e.second << " ";
        }
        f << "\n";
        for (auto id : st[i].ids) {
            f << id << " ";
        }
        f << "\n";
    }
    f.close();
}