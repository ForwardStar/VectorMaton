// Partially generated by ChatGPT (14/01/2026)

#include <atomic>
#include <cstddef>
#include <vector>

class MPMCQueue {
public:
    explicit MPMCQueue(size_t capacity)
        : capacity_(capacity),
          mask_(capacity - 1),
          buffer_(capacity),
          head_(0),
          tail_(0)
    {
        // Capacity must be a power of two
        for (size_t i = 0; i < capacity_; ++i) {
            buffer_[i].seq.store(i, std::memory_order_relaxed);
        }
    }

    bool enqueue(int value) {
        Cell* cell;
        size_t pos = tail_.load(std::memory_order_relaxed);

        for (;;) {
            cell = &buffer_[pos & mask_];
            size_t seq = cell->seq.load(std::memory_order_acquire);
            intptr_t dif = (intptr_t)seq - (intptr_t)pos;

            if (dif == 0) {
                if (tail_.compare_exchange_weak(
                        pos, pos + 1, std::memory_order_relaxed))
                    break;
            } else if (dif < 0) {
                return false; // queue full
            } else {
                pos = tail_.load(std::memory_order_relaxed);
            }
        }

        cell->value = value;
        cell->seq.store(pos + 1, std::memory_order_release);
        return true;
    }

    bool dequeue(int& value) {
        Cell* cell;
        size_t pos = head_.load(std::memory_order_relaxed);

        for (;;) {
            cell = &buffer_[pos & mask_];
            size_t seq = cell->seq.load(std::memory_order_acquire);
            intptr_t dif = (intptr_t)seq - (intptr_t)(pos + 1);

            if (dif == 0) {
                if (head_.compare_exchange_weak(
                        pos, pos + 1, std::memory_order_relaxed))
                    break;
            } else if (dif < 0) {
                return false; // queue empty
            } else {
                pos = head_.load(std::memory_order_relaxed);
            }
        }

        value = cell->value;
        cell->seq.store(pos + capacity_, std::memory_order_release);
        return true;
    }

    int size() {
        return tail_.load() - head_.load();
    }

private:
    struct Cell {
        std::atomic<size_t> seq;
        int value;
    };

    const size_t capacity_;
    const size_t mask_;
    std::vector<Cell> buffer_;

    std::atomic<size_t> head_;
    std::atomic<size_t> tail_;
};