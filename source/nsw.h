// Partially generated by Doubao (01/08/2025)

#ifndef NSW_H
#define NSW_H

#include "headers.h"

extern std::vector<std::vector<float>> vec;

class NSW {
private:
    struct Node {
        int id;
        std::vector<int> neighbors;
        Node(int _id) : id(_id) {}
    };

    std::vector<Node> nodes;
    int M;
    int efConstruction;

    // Greedy search to find candidate nodes
    std::vector<int> greedySearch(int entry, const std::vector<float>& q, int ef) const;

    // Prune candidates to keep the closest M nodes
    std::vector<int> prune(const std::vector<int>& C, int u, int M) const;

public:
    NSW(int m = 16, int efCon = 200) : M(m), efConstruction(efCon) {}

    // Calculate Euclidean distance between two vectors
    float distance(const std::vector<float>& a, const std::vector<float>& b) const {
        float dist = 0.0;
        for (size_t i = 0; i < a.size(); ++i) {
            float diff = a[i] - b[i];
            dist += diff * diff;
        }
        return std::sqrt(dist);
    }

    // Insert a new vector into the NSW graph
    void insert(int id) {
        nodes.emplace_back(id);
        if (nodes.empty()) {
            return;
        }
        int entry = 0, newNodeIdx = nodes.size() - 1;
        std::vector<int> C = greedySearch(entry, vec[id], efConstruction);
        std::vector<int> NG = prune(C, newNodeIdx, M);
        for (int v : NG) {
            nodes[newNodeIdx].neighbors.emplace_back(v);
            nodes[v].neighbors.emplace_back(newNodeIdx);
            if (nodes[v].neighbors.size() > static_cast<size_t>(M)) {
                nodes[v].neighbors = prune(nodes[v].neighbors, v, M);
            }
        }
    }

    // Search for k nearest neighbors of a query vector
    std::vector<int> searchKNN(const std::vector<float>& q, int k, int ef = 10) const {
        if (nodes.empty()) {
            return {};
        }
        int entry = 0;
        return greedySearch(entry, q, ef);
    }
};

#endif // NSW_H