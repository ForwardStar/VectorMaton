// Partially generated by Doubao (01/08/2025)

#ifndef NSW_H
#define NSW_H

#include "headers.h"

class NSW {
private:
    // Greedy search to find candidate nodes
    std::vector<int> greedySearch(int entry, const std::vector<float>& q, int ef) const;

    // Prune candidates to keep the closest M nodes
    std::vector<int> prune(const std::vector<int>& C, int u, int M) const;

public:
    struct Node {
        int id = -1;
        std::vector<int> neighbors;
        Node(int _id) : id(_id) {}
        Node() {}
    };

    std::vector<std::vector<float>> vec_materialized = {}; // Local vectors
    std::vector<std::vector<float>> &vec;
    std::vector<Node> nodes;

    int M;
    int efConstruction;

    NSW(int m = 32, int efCon = 400) : M(m), efConstruction(efCon), vec(vec_materialized) {}
    NSW(std::vector<std::vector<float>> &vec_data, int m = 32, int efCon = 400) : M(m), efConstruction(efCon), vec(vec_data) {}
    NSW(NSW &other) : vec(other.vec) {
        nodes.resize(other.nodes.size());
        for (size_t i = 0; i < other.nodes.size(); i++) {
            nodes[i].id = other.nodes[i].id;
            nodes[i].neighbors.resize(other.nodes[i].neighbors.size());
            std::move(other.nodes[i].neighbors.begin(), other.nodes[i].neighbors.end(), nodes[i].neighbors.begin());
        }
        M = other.M;
        efConstruction = other.efConstruction;
    }

    // Insert a new vector into the NSW graph
    void insert(int id) {
        nodes.emplace_back(id);
        if (nodes.size() == 1) {
            return;
        }
        int entry = 0, newNodeIdx = nodes.size() - 1;
        std::vector<int> C = greedySearch(entry, vec[id], efConstruction);
        std::vector<int> NG = prune(C, newNodeIdx, M);
        for (int v : NG) {
            std::cout << nodes[v].id << " ";
            nodes[newNodeIdx].neighbors.emplace_back(v);
            nodes[v].neighbors.emplace_back(newNodeIdx);
            if (nodes[v].neighbors.size() > static_cast<size_t>(M)) {
                nodes[v].neighbors = prune(nodes[v].neighbors, v, M);
            }
        }
        std::cout << std::endl;
    }

    // Search for k nearest neighbors of a query vector
    std::vector<int> searchKNN(const std::vector<float>& q, int k = 10) const {
        if (nodes.empty()) {
            return {};
        }
        int entry = 0;
        return greedySearch(entry, q, k);
    }
};

#endif // NSW_H