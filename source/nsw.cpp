// Partially generated by Doubao (01/08/2025)

#include "nsw.h"

std::vector<int> NSW::greedySearch(int entry, const float* q, int ef) const {
    std::unordered_set<int> visited = {entry};
    std::priority_queue<std::pair<float, int>> C;
    C.emplace(-distance(vec_ptr[nodes[entry].id], q, dim), entry);
    std::priority_queue<std::pair<float, int>> W;
    W.emplace(distance(vec_ptr[nodes[entry].id], q, dim), entry);

    while (!C.empty()) {
        // Find the nearest node in C to query q
        int u = C.top().second;
        C.pop();

        // Find the farthest node in W from query q
        int f = W.top().second;

        // Termination condition
        if (distance(vec_ptr[nodes[u].id], q, dim) > distance(vec_ptr[nodes[f].id], q, dim)) {
            break;
        }

        // Process neighbors of u
        for (int v : nodes[u].neighbors) {
            if (visited.find(v) == visited.end()) {
                visited.insert(v);
                float distVQ = distance(vec_ptr[nodes[v].id], q, dim);
                float distFQ = distance(vec_ptr[nodes[f].id], q, dim);
                if (distVQ < distFQ || W.size() < static_cast<size_t>(ef)) {
                    C.emplace(-distance(vec_ptr[nodes[v].id], q, dim), v);
                    W.emplace(distance(vec_ptr[nodes[v].id], q, dim), v);
                }
                // Update f if W size exceeds ef
                if (W.size() > static_cast<size_t>(ef)) {
                    W.pop();
                }
            }
        }
    }

    std::vector<int> results;
    while (!W.empty()) {
        results.emplace_back(W.top().second);
        W.pop();
    }
    std::reverse(results.begin(), results.end());
    return results;
}

std::vector<int> NSW::prune(const std::vector<int>& C, int u, int M) const {
    if (C.empty() || M <= 0) {
        return {};
    }

    // Sort nodes in C by distance to u
    std::vector<std::pair<float, int>> distNodes;
    for (int v : C) {
        distNodes.emplace_back(distance(vec_ptr[nodes[u].id], vec_ptr[nodes[v].id], dim), v);
    }
    std::sort(distNodes.begin(), distNodes.end());

    std::vector<int> R;

    for (const auto& dn : distNodes) {
        int v = dn.second;
        bool add = true;
        for (int w : R) {
            if (distance(vec_ptr[nodes[v].id], vec_ptr[nodes[w].id], dim) < dn.first) {
                add = false;
                break;
            }
        }
        if (add) {
            R.push_back(v);
            if (R.size() == static_cast<size_t>(M)) {
                break;
            }
        }
    }
    return R;
}